*reference:《ARM64体系结构编程与实践》奔跑吧Linux社区*
*reference: https://github.com/runninglinuxkernel/arm64_programming_practice*
***
*一些概念*
- 处理机(Processing Element,PE):在 ARM 公司的官方技术手册中提到的一个概念,
把处理器处理事务的过程抽象为处理机。
- 执行状态(execution state):处理器运行时的环境,包括寄存器的位宽、支持的指
令集、异常模型、内存管理以及编程模型等。ARMv8 体系结构定义了两个执行
状态。
-  AArch64:64 位的执行状态。
	- 提供 31 个 64 位的通用寄存器。
	- 提供 64 位的程序计数(Program Counter,PC)指针寄存器、栈指针(Stack
		Pointer,SP)寄存器以及异常链接寄存器(Exception Link Register,ELR)。
		提供 A64 指令集。
	- 定义 ARMv8 异常模型,支持 4 个异常等级,即 EL0~EL3。
	- 提供 64 位的内存模型。
	-   定义一组处理器状态(PSTATE)用来保存 PE 的状态。
 - AArch32:32 位的执行状态。
	- 提供 13 个 32 位的通用寄存器,再加上 PC 指针寄存器、SP 寄存器、链接寄
		存器(Link Register,LR).
	- 支持两套指令集,分别是 A32 和 T32(Thumb 指令集)指令集。
    - 支持 ARMv7-A 异常模型,基于 PE 模式并映射到 ARMv8 的异常模型中。
	-  定义一组 PSTATE 用来保存 PE 的状态。
- ARMv8 指令集:ARMv8 体系结构根据不同的执行状态提供不同指令集的支持。
	- A64 指令集:运行在 AArch64 状态下,提供 64 位指令集支持。
	- A32 指令集:运行在 AArch32 状态下,提供 32 位指令集支持。
	- T32 指令集:运行在 AArch32 状态下,提供 16 位和 32 位指令集支持。
- 系统寄存器命名:在 AArch64 状态下,很多系统寄存器会根据不同的异常等级提供不
同的变种寄存器。系统寄存器的使用方法如下。
    ```<register_name>_Elx //最后一个字母 x 可以表示 0、1、2、3```
***
特权等级
- EL0:用户特权,用于运行普通用户程序
- EL1:系统特权,通常用于操作系统内核。如果系统使能了虚拟化扩展,运行虚拟机
操作系统内核
- EL2:运行虚拟化扩展的虚拟机监控器(hypervisor)
- EL3:运行安全世界中的安全监控器(secure monitor)
***
A64指令编码格式
![[Pasted image 20240724145921.png]]
当根据 op0 字段确定了指令的分类之后,还需要进一步确定指令的细分类别
***
加载与存储指令
![[Pasted image 20240724150220.png]]
![[Pasted image 20240724150236.png]]
- 当使用寄存器作为基地址时,把 SP(栈指针)寄存器当作第 31 个通用寄存器。
- 当用作源寄存器操作数时,把 XZR 当作第 31 个通用寄存器
***
![[Pasted image 20240724150713.png]]
***
*加载与存储指令*
>LDR 目标寄存器, <存储器地址> //把存储器地址中的数据加载到目标寄存器中 
>STR 源寄存器, <存储器地址>　//把寄存器的数据存储到存储器中
![[Pasted image 20240724152412.png]]

- **基地址模式**
> 加载Xn寄存器的内存地址的内容到 Xt 寄存器
> `LDR Xt, [Xn]`
> 把 Xt 寄存器中的内容存储到 Xn 寄存器的内存地址中
> `STR Xt, [Xn]`
- **基地址加偏移量模式**
 >把 Xn 寄存器中的内容加一个偏移量(offset 必须是 8 的倍数),以相加的结果作
 >为内存地址,加载此内存地址的内容到 Xt 寄存器
 >`LDR Xt, [Xn, $offset]`
 >把 Xt 寄存器的值存储到以 Xn 寄存器的值加一个偏移量(offset 乘以 8)表示的内存
 >地址中
 >`STR Xt, [Xn, $offset]`
- **基地址扩展模式**
>`LDR <Xt>, [<Xn>, (<Xm>){, <extend> {<amount>}}]`
>`STR <Xt>, [<Xn>, (<Xm>){, <extend> {<amount>}}]`
>Xt:目标寄存器,它对应指令编码中的 Rt 字段。
>Xn:基地址寄存器,它对应指令编码中的 Rn 字段。
>Xm:用来表示偏移的寄存器,它对应指令编码中的 Rm 字段。
>extend:扩展/移位指示符,默认是 LSL,它对应指令编码中的 option 字段。
>	当 option 字段为 010 时,extend 编码为 UXTW。UXTW 表示从寄存器中提取 32
位数据,其余高位填充 0。
>	当 option 字段为 011 时,extend 编码为 LSL。LSL 表示逻辑左移。
>	当 option 字段为 110 时,extend 编码为 SXTW。SXTW 表示从寄存器中提取 32 位
数据,其余高位需要有符号扩展。
>	当 option 字段为 111 时,extend 编码为 SXTX。SXTX 表示从寄存器中提取 64 位数据。
>amount:索引偏移量,它对应指令编码中的 S 字段,当 extend 参数不是 LSL 时有效。
>	当 S 字段为 0 时,amount 为 0。
>	当 S 字段为 1 时,amount 为 3。
- **变基模式**
1. 前变基(pre-index)模式:先更新偏移量地址,后访问内存地址。
2. 后变基(post-index)模式:先访问内存地址,后更新偏移量地址。
- **前变基模式**
>`LDR <Xt>, [<Xn|SP>, #<simm>]!`
>更新 Xn/SP 寄存器的值为 Xn/SP 寄存器的
值加 simm。然后,以新的 Xn/SP 寄存器的值为内存地
址,加载该内存地址的值到 Xt 寄存器

- **后变基模式**
>`LDR <Xt>, [<Xn|SP>], #<simm>`
>以 Xn/SP 寄存器的值为内存地址,加载
该内存地址的值到 Xt 寄存器,然后更新 Xn 寄存
器的值为 Xn/SP 寄存器的值加 simm

- **PC相对地址**
>`LDR <Xt>, <label>`
>指令读取 label 所在内存地址的内容到 Xt 寄存器中。但是这个 label 必须在当前 PC 地
址前后 1 MB 的范围内

- `LDR伪指令`
*伪指令是对汇编器发出的命令,它在源程序汇编期间由汇编器处理。伪指令可以完成选择
处理器、定义程序模式、定义数据、分配存储区、指示程序结束等功能。*
>`LDR Xt,=<label>　//把 label 标记的地址加载到 Xt 寄存器`
>LDR 指令既可以是在大范围内加载地址的伪指令,也可以是普通的内存访问指令。当它的
第二个参数前面有“=”时,表示伪指令;否则,表示普通的内存访问指令。


