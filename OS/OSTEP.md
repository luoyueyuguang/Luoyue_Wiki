## what is three easy pieces
这本书认为操作系统要做到这三部分的功能:虚拟化，并发，与持久化
## 虚拟化
### CPU虚拟化
#### 调度
现在，我们来谈一谈调度
首先，假设一个简单的调度，对工作任务有如下假设

**1．每一个工作运行相同的时间。
2．所有的工作同时到达。
3．一旦开始，每个工作保持运行直到完成。
4．所有的工作只是用 CPU（即它们不执行 IO 操作）。
5．每个工作的运行时间是已知的。**

这些假设虽然不现实，却有助于我们理解


我们再来谈一下调度的指标
***$T_{周转时间}=T_{完成时间} - T_{到达时间}$***
这个指标体现了公平


***FIFO(First in first out)***
现在，我们来讨论一下`FIFO(First in first out)`，即先到先服务。非常朴素的一个实现
假设三个进程
```
A:10s
B:10s
C:10s
```
其平均周转时间为$(10 + 20 + 30) / 3 = 20$
但是如果`A`变为`100s`
其平均周转时间为$(100 + 110 + 120) / 3 = 110$
这种现象一般被成为`护航效应(convoy effect)`,一些耗时较少的潜在资源消费者被排在重量级的资源消费者之后

***SJF(Shortest Job First)***
让我们看一看`SJF`,最短任务优先,它先运行最短的任务，其次是次短的任务，那么ABC的调度时间将会变为$(10 + 20 + 120) /3 = 50$,但这基于同时到达这一个假设。放宽这个假设，让`B`和`C`晚到达`10s`
平均周转时间变为$100 + (110 - 10) + (120 - 10) / 3 = 103.33$
这依然很长

***STCF(Shortest Time-to-Completion First) / PSJF(Preemptive Shortest Job First )***
让我们放宽一下**工作必须保持运行直到完成**这一条件，进入抢占式的世界。`STCF`从某种意义上来说就是给`SJF`加抢占式，每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。
平均周转时间可以达到$(10 - 0)(A) + (20 -10)(B) + (30 - 20)(C) + (120 - 30)(A) / 3 = 50$


现在，让我们再加入一个新指标，`响应时间(response time）`
$T_{响应时间} = T_{首次运行}−T_{到达时间}$
上面这个工作的响应时间为$(0 - 0) + (10 - 10) + (20 -10) / 3 = 3.33$


***Round-Robin，RR***
让我们开看一下轮转算法，其思想很简单: `RR`在一个时间片(`time slice`有时称为`调度量子，scheduling quantum`）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直
到结束。如果时间片为`1s`,`rr`的响应时间为$(0 + 1 + 2)/3＝1$，余




### 内存虚拟化

在最初的时候，操作系统的内存不多，需求也很少，没有任何抽象。操作系统在内存前边，程序接着在后边。

多道程序与时分共享的出现使得交互性变得重要，人们将不同的进程放在内存，时分共享得到了实现。但是多个程序的驻留使得保护成为重要问题。

#### 地址空间
地址空间是一个易用的物理内存抽象，进程空间包含代码，栈，堆。栈向上增长，堆向上增长。地址空间是对运行程序的抽象，程序加载到不同地方，地址空间内抽象为`0KB`地址的程序实际上可能存放在`320KB`。这就是内存虚拟化。

#### 内存虚拟化的目标
- **透明(transparency)**：让运行的程序看不见，好像都有自己的私有物理内存，这实际上有内存复用的原因。
- **效率(efficiency)**：操作系统应该追求虚拟化尽可能高效，这可能需要内存的支持。
- **保护(protection)**：操作系统应确保进程受到保护，不受其他进程影响。

#### 地址转换
操作系统需要借用硬件的支持来进行地址的转换
我们可以动态（基于硬件）重定位
每个cpu需要两个硬件寄存器：基址寄存器和界限寄存器
$physical\space address = virtual\space address + base$
物理地址由虚拟地址加上基址寄存器中的内容得到


## 持久性
